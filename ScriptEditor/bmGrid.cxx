/*=========================================================================

  Program:   BatchMake
  Module:    bmGrid.cxx
  Language:  C++
  Date:      $Date$
  Version:   $Revision$
  Copyright (c) 2005 Insight Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
=========================================================================*/

#include "bmGrid.h"
#include <stdio.h>
#include <ctime>
  
namespace bm {

/** Constructor */
Grid::Grid()
{
  m_FileName = "";
  m_CurrentScopeFile = "";
}

/** Destructor */
Grid::~Grid()
{
}


/** Return the current scope file */
const char* Grid::GetCurrentScopeFile()
{
  if(m_CurrentScopeFile.size() == 0)
    {
    char* tempchar = new char[25];
    sprintf(tempchar,"%d.bms.tmp",time(NULL));
    m_CurrentScopeFile = tempchar;
    delete [] tempchar;
    }
  return m_CurrentScopeFile.c_str();
}


/** Add an application to the list of applications to generate */
void Grid::AddApplication(ApplicationWrapper* app)
{
  m_ApplicationsList.push_back(*app);
}

/** Write a kwgrid script */
void Grid::WriteGAD()
{
 if(m_FileName.size() == 0)
    {
    std::cout << "Grid::WriteGAD() : Please set a filename" << std::endl;
    return;
    }
  FILE* fic = fopen(m_FileName.c_str(),"wb");
  
  if(!fic)
    {
    std::cout << "Grid::WriteGAD() : Cannot create GAD script" << std::endl;
    return;
    }

  // Write the header
  fprintf(fic,"# Script generated by BatchMake (c) Kitware Inc.\n");
  fprintf(fic,"# (c) Kitware Inc 2006\n");
  fprintf(fic,"# More information at: http://public.kitware.com/BatchMake\n\n");

  fprintf(fic,"<?xml version=\"1.0\" encoding=\"UTF-8\" \n?>");
}

/** Write a condor script */
void Grid::WriteCondor()
{
  if(m_FileName.size() == 0)
    {
    std::cout << "Grid::WriteCondor() : Please set a filename" << std::endl;
    return;
    }
  FILE* fic = fopen(m_FileName.c_str(),"wb");
  
  if(!fic)
    {
    std::cout << "Grid::WriteCondor() : Cannot create Condor script" << std::endl;
    return;
    }
  
  // Write the header
  fprintf(fic,"# Script generated by BatchMake (c) InsightSoftwareConsortium\n");
  fprintf(fic,"# (c) Kitware Inc 2006\n");
  fprintf(fic,"# More information at: http://public.kitware.com/BatchMake\n");
  
  fprintf(fic,"universe       = vanilla\n");
  fprintf(fic,"output         = bmGrid.out.txt\n");             
  fprintf(fic,"error          = bmGrid.error.txt\n");            
  fprintf(fic,"log            = bmGrid.log.txt\n");
  
  // Add the executable
  std::vector<ApplicationWrapper>::iterator it = m_ApplicationsList.begin();
  while(it != m_ApplicationsList.end())
    {
    fprintf(fic,"executable    = %s\n",(*it).GetApplicationPath().toChar());
    fprintf(fic,"arguments     = %s\n",(*it).GetCurrentCommandLineArguments(true).c_str());  
    
#ifdef WIN32 
    fprintf(fic,"requirements  = (OpSys == \"WINNT50\") || (OpSys == \"WINNT51\") \n");
#endif

    // Check if we have external data
    const std::vector<ApplicationWrapperParam> & params = (*it).GetParams();
    std::vector<ApplicationWrapperParam>::const_iterator itParams = params.begin();

    std::string externalData = "";
    while(itParams != params.end())
      {
      if((*itParams).GetExternalData())
        {
        if(externalData.size()>0)
          {
          externalData += ",";
          }
        externalData += (*itParams).GetValue().toChar();
        }
      itParams++;
      }

    if(externalData.size() > 0)
      {
      fprintf(fic,"should_transfer_files = yes\n");
      fprintf(fic,"transfer_input_files = %s\n",externalData.c_str());
      fprintf(fic,"when_to_transfer_output = ON_EXIT_OR_EVICT\n");
      }

    fprintf(fic,"queue 1\n");
    it++;
    }
  fclose(fic);
}

} // end namespace bm
