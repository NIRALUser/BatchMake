/*=========================================================================

  Program:   BatchMake
  Module:    bmGrid.cxx
  Language:  C++
  Date:      $Date$
  Version:   $Revision$
  Copyright (c) 2005 Insight Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
=========================================================================*/

#include "bmGrid.h"
#include <stdio.h>
#include <ctime>
  
namespace bm {

/** Constructor */
Grid::Grid()
{
  m_FileName = "";
  m_CurrentScopeFile = "";
  m_DataHost = "";
  m_OutputHost = "";
  m_OutputDirectory = "";
  m_DataDirectory = "";
  m_Distributed = false; // by default everything is sequential
  m_SingleNode = false;
  m_SingleNodeTransition = false;
  m_DistributedTransition = false;
}

/** Destructor */
Grid::~Grid()
{
}


/** Return the current scope file */
const char* Grid::GetCurrentScopeFile()
{
  if(m_CurrentScopeFile.size() == 0)
    {
    char* tempchar = new char[25];
    sprintf(tempchar,"%d.bms.tmp",time(NULL));
    m_CurrentScopeFile = tempchar;
    delete [] tempchar;
    }
  return m_CurrentScopeFile.c_str();
}

/** */
void Grid::SetGridBarrier()
{
  m_DistributedSyncBarrier.push_back(m_ApplicationsList.size()-1);
}

/** Add an application to the list of applications to generate */
void Grid::AddApplication(ApplicationWrapper* app,const char* datadir,const char* outputdir)
{
  (*app).SetDataHost(m_DataHost.c_str());
  (*app).SetOutputHost(m_OutputHost.c_str());
  
  if(m_SingleNodeTransition)
    {
   (*app).SetSingleNode(2);
    m_SingleNodeTransition = false;
    }
  else if(m_SingleNode)
    {
    (*app).SetSingleNode(1);
    }
  else
    {
    (*app).SetSingleNode(0);
    }

  if(datadir)
    {
    (*app).SetDataDirectory(datadir);
    }
  else
    {
    (*app).SetDataDirectory(m_DataDirectory.c_str());
    }

   if(outputdir)
    {
    (*app).SetOutputDirectory(outputdir);
    }
  else
    {
    (*app).SetOutputDirectory(m_OutputDirectory.c_str());
    }

  if(m_DistributedTransition && m_Distributed)
    {
    (*app).SetDependsOn(m_DistributedSyncBarrier[m_DistributedSyncBarrier.size()-1]);
    m_DistributedTransition = false;
    }
  else
    {
    (*app).SetDependsOn(-1);
    }

  m_ApplicationsList.push_back(*app);
}

/** Return a filename for a full path */
std::string Grid::GetFilename(const char* fullpath)
{
  std::string fullname = fullpath;
  long int pos = fullname.find_last_of("/");
  if(pos != -1)
     {
     return fullname.substr(pos+1,fullname.size()-pos-1);
     }
  pos = fullname.find_last_of("\\");
  if(pos != -1)
     {
     return fullname.substr(pos+1,fullname.size()-pos-1);
     }
  return fullpath;
}

/** Write a kwgrid script */
void Grid::WriteGAD()
{
 if(m_FileName.size() == 0)
    {
    std::cout << "Grid::WriteGAD() : Please set a filename" << std::endl;
    return;
    }
  FILE* fic = fopen(m_FileName.c_str(),"wb");
  
  if(!fic)
    {
    std::cout << "Grid::WriteGAD() : Cannot create GAD script" << std::endl;
    return;
    }

  // Write the header
  fprintf(fic,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
  fprintf(fic,"<gridApplication\n");
  fprintf(fic,"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n");
  fprintf(fic,"xsi:noNamespaceSchemaLocation=\"grid-application-description.xsd\"\n");
  fprintf(fic,"name=\"BatchMake Script\"\n");
  fprintf(fic,"description=\"Script generated by BatchMake (c) Kitware Inc.\">\n");

  unsigned int appnum = 1;
  unsigned int inFile = 1;
  unsigned int outFile = 1;

  // Add the applicationComponent
  std::vector<ApplicationWrapper>::iterator it = m_ApplicationsList.begin();
  while(it != m_ApplicationsList.end())
    {
    // Find the current dependency
    ApplicationWrapper* dependApp = NULL;
    std::string dependencyName = "";
    if((*it).GetDependsOn() == -1 && it!=m_ApplicationsList.begin())
      {
      std::vector<ApplicationWrapper>::iterator itprev = it;
      itprev--;
      dependApp = &(*itprev);
      }
    else if((*it).GetDependsOn() >= 0)
      {
      dependApp = &(m_ApplicationsList[(*it).GetDependsOn()]);
      }

     
  // If this is not the first application 
  if(it != m_ApplicationsList.begin()
    && ((*it).GetSingleNode() == 2))
    {
    fprintf(fic,"</componentActionList>\n");
    fprintf(fic,"</applicationComponent>\n\n");
    fprintf(fic,"<applicationComponent name=\"task%d\" remoteExecution=\"true\">\n",appnum); 
    fprintf(fic,"<componentActionList>\n");
    }

    std::vector<std::string> dependencies;

    // Check if we have external data
    const std::vector<ApplicationWrapperParam> & params = (*it).GetParams();
    std::vector<ApplicationWrapperParam>::const_iterator itParams = params.begin();
    while(itParams != params.end())
      {
      if((*itParams).GetExternalData() == 1 && (*itParams).GetValue().length() > 0) // DATA_IN
        {
        fprintf(fic," <componentAction type=\"DataRelocation\" name=\"InputFile%d\">\n",inFile);
        fprintf(fic,"  <parameter name=\"Host\" value=\"%s\"/>\n",(*it).GetDataHost());
        fprintf(fic,"  <parameter name=\"Description\" value=\"\"/>\n");
        fprintf(fic,"  <parameter name=\"Direction\" value=\"In\"/>\n");
        fprintf(fic,"  <parameter name=\"Protocol\" value=\"gsiftp\"/>\n");
        fprintf(fic,"  <parameter name=\"SourceDataPath\" value=\"%s%s\"/>\n",(*it).GetDataDirectory(),(*itParams).GetValue().toChar());
        fprintf(fic,"  <parameter name=\"DestDataPath\" value=\"%s\"/>\n",
                              this->GetFilename((*itParams).GetValue().toChar()).c_str());
     
        if(dependApp)
          {
          fprintf(fic,"  <dependency name=\"%s\"/>\n",dependApp->GetDependencyTag());
          }
        fprintf(fic," </componentAction>\n");
        char* dep = new char[255];
        sprintf(dep,"InputFile%d",inFile);
        (*it).SetDependencyTag(dep);
        dependencies.push_back(dep);
        delete [] dep;
        inFile++;
        }
      itParams++;
      }

  char* temp = new char[10];
  sprintf(temp,"app%d",appnum);
  (*it).SetDependencyTag(temp);
  delete [] temp;

  fprintf(fic," <componentAction type=\"JobSubmission\" name=\"app%d\">\n",appnum);
  fprintf(fic,"  <parameter name=\"Executable\" value=\"%s\"/>\n"
                                       ,(*it).GetApplicationPath().toChar());

  std::string commandline = "";
  itParams = params.begin();
  unsigned int nParams = 0;
  while(itParams != params.end())
    {
    if((*itParams).IsValueDefined() && !(*itParams).GetParent())
      {
      if(nParams>0)
        {
        commandline += " ";
        }
      commandline += "{";
      commandline += (*itParams).GetName().toChar();
      commandline += "}";
      nParams++;
      }
    itParams++;
    }
  fprintf(fic,"  <parameter name=\"Arguments\"  value=\"%s\"/>\n",commandline.c_str());

  // Write each argument out
  itParams = params.begin();
  nParams = 1;
  while(itParams != params.end())
    {
    if((*itParams).IsValueDefined() && !(*itParams).GetParent())
      {
      if((*itParams).GetType() == ApplicationWrapperParam::Flag)
        {
        std::string optional = "false";
        if((*itParams).GetOptional())
         {
         optional = "true";
         }

        std::string syntax = (*itParams).GetValue().toChar();

        std::vector<ApplicationWrapperParam>::const_iterator itChildren = itParams;
        itChildren++;
        while(itChildren!=params.end() && (*itChildren).GetParent())
          {
          syntax += " {";
          syntax += (*itChildren).GetName().toChar();
          syntax += "}";

          // Check if we have only one value
          std::string value = (*itChildren).GetValue().toChar();
          unsigned int nValues = 0;
          for(unsigned int i=0;i<value.size();i++)
            {
            if(value[i]=='\"')
              {
              // Go to the next '\"' and increase the nValues
              long int pos = value.find("\"",i+1);
              if(pos != -1)
                {
                i=pos+1;
                nValues++;
                }
              }
            else if(value[i] == ' ')
              {
              nValues++;
              }
            }

           for(unsigned int j=1;j<nValues;j++)
             {
             syntax += " {";
             syntax += (*itChildren).GetName().toChar();
             char* num = new char[10];
             sprintf(num,"%d",j);
             syntax += ".";
             syntax += num;
             syntax += "}";
             delete [] num;
             }
          itChildren++;
          }
      
        fprintf(fic,"  <group name=\"%s\" syntax=\"%s\" optional=\"%s\" selected=\"true\">\n"
                                ,(*itParams).GetName().toChar()
                                ,syntax.c_str()
                                ,optional.c_str());

        itChildren = itParams;
        itChildren++;
        while(itChildren!=params.end() && (*itChildren).GetParent())
          {
          std::string value = (*itChildren).GetValue().toChar();          
          // Extract the values
          std::vector<std::string> values;
          unsigned int startWord = 0;
          for(unsigned int i=0;i<value.size();i++)
            {
            if(value[i]=='\"')
              {
              startWord=i+1;
              // Go to the next '\"' and increase the nValues
              long int pos = value.find("\"",i+1);
              if(pos != -1)
                {
                values.push_back(value.substr(startWord,pos-i-1));
                i=pos+1;
                }
              }
            else if(value[i] == ' ')
              {
              values.push_back(value.substr(startWord,i-startWord));
              startWord =i+1; // WARNING this is not always true!
              }
            }

          // If the size of the list is null, something is wrong, well we have only one value
          if(values.size() == 0)
            {
            values.push_back(value);
            }


          std::vector<std::string>::const_iterator itV=values.begin();
          unsigned int i=0;
          while(itV!=values.end())
            {
            if(itV==values.begin())
              {
              fprintf(fic,"   <argument name=\"%s\" value=\"%s\" type=\"%s\"/>\n",
                           (*itChildren).GetName().toChar(),(*itV).c_str(),
                           (*itChildren).GetTypeAsChar());
              }
            else
              {
             fprintf(fic,"   <argument name=\"%s.%d\" value=\"%s\" type=\"%s\"/>\n",
                           (*itChildren).GetName().toChar(),i,(*itV).c_str(),
                           (*itChildren).GetTypeAsChar());
           
              }
            i++;
            itV++;
            }
          itChildren++;
          }


        fprintf(fic,"  </group>\n");
        }
      else
        {
        MString value = (*itParams).GetValue();
        value = value.removeChar('\"');
        fprintf(fic,"  <argument name=\"%s\" value=\"%s\" type=\"%s\"/>\n",
                           (*itParams).GetName().toChar(),value.toChar(),
                           (*itParams).GetTypeAsChar());
        }
      }
    nParams++;
    itParams++;
    }

  std::vector<std::string>::const_iterator itDep = dependencies.begin();
  while(itDep != dependencies.end())
    {
    fprintf(fic,"  <dependency name=\"%s\"/>\n",(*itDep).c_str());
    itDep++;  
    }

  if(dependencies.size() == 0 && dependApp)
    {
    fprintf(fic,"  <dependency name=\"%s\"/>\n",dependApp->GetDependencyTag());
    }
  
  fprintf(fic," </componentAction>\n");
  dependencies.clear();    
  
  char* appName = new char[255];
  sprintf(appName,"app%d",appnum);

  itParams = params.begin();
  while(itParams != params.end())
    {
    if((*itParams).GetExternalData() == 2 && (*itParams).GetValue().length() > 0) // DATA_OUT
      {
      fprintf(fic," <componentAction type=\"DataRelocation\" name=\"OutputFile%d\">\n",outFile);
      fprintf(fic,"  <parameter name=\"Host\" value=\"%s\"/>\n",(*it).GetOutputHost());
      fprintf(fic,"  <parameter name=\"Description\" value=\"\"/>\n");
      fprintf(fic,"  <parameter name=\"Direction\" value=\"Out\"/>\n");
      fprintf(fic,"  <parameter name=\"Protocol\" value=\"gsiftp\"/>\n");
      fprintf(fic,"  <parameter name=\"SourceDataPath\" value=\"%s\"/>\n",(*itParams).GetValue().toChar());
      fprintf(fic,"  <parameter name=\"DestDataPath\" value=\"%s%s\"/>\n",(*it).GetOutputDirectory(),(*itParams).GetValue().toChar());
      fprintf(fic," <dependency name=\"%s\"/>\n",appName);
      fprintf(fic," </componentAction>\n");
      char* dep = new char[255];
      sprintf(dep,"OutputFile%d",outFile);
      (*it).SetDependencyTag(dep);
      dependencies.push_back(dep);
      delete [] dep;
      outFile++;
      }
    itParams++;
    }

  delete [] appName;
  it++;
  appnum++;
  }

  fprintf(fic,"</componentActionList>\n");
  fprintf(fic,"</applicationComponent>\n\n");

  fprintf(fic,"</gridApplication>\n");
  fclose(fic);
}

/** Write a shell script */
void Grid::WriteShell()
{
 if(m_FileName.size() == 0)
    {
    std::cout << "Grid::WriteShell() : Please set a filename" << std::endl;
    return;
    }

  FILE* fic = fopen(m_FileName.c_str(),"wb");
  if(!fic)
    {
    std::cout << "Grid::WriteShell() : Cannot create GAD script" << std::endl;
    return;
    }

  // Write the header
  fprintf(fic,"# Script generated by BatchMake (c) Kitware Inc.\n");
  fprintf(fic,"# (c) Kitware Inc 2006\n");
  fprintf(fic,"# More information at: http://public.kitware.com/BatchMake\n\n");

  fprintf(fic,"#!/bin/bash\n\n");

  // Add the executable
  std::vector<ApplicationWrapper>::iterator it = m_ApplicationsList.begin();
  while(it != m_ApplicationsList.end())
    {
    fprintf(fic,"%s %s\n",(*it).GetApplicationPath().toChar(),
                          (*it).GetCurrentCommandLineArguments(false).c_str());
    it++;
    }
 
  fclose(fic);
}



/** Write a condor script */
void Grid::WriteCondor()
{
  if(m_FileName.size() == 0)
    {
    std::cout << "Grid::WriteCondor() : Please set a filename" << std::endl;
    return;
    }
  FILE* fic = fopen(m_FileName.c_str(),"wb");
  
  if(!fic)
    {
    std::cout << "Grid::WriteCondor() : Cannot create Condor script" << std::endl;
    return;
    }
  
  // Write the header
  fprintf(fic,"# Script generated by BatchMake (c) InsightSoftwareConsortium\n");
  fprintf(fic,"# (c) Kitware Inc 2006\n");
  fprintf(fic,"# More information at: http://public.kitware.com/BatchMake\n");
  
  fprintf(fic,"universe       = vanilla\n");
  fprintf(fic,"output         = bmGrid.out.txt\n");             
  fprintf(fic,"error          = bmGrid.error.txt\n");            
  fprintf(fic,"log            = bmGrid.log.txt\n");
  
  // Add the executable
  std::vector<ApplicationWrapper>::iterator it = m_ApplicationsList.begin();
  while(it != m_ApplicationsList.end())
    {
    fprintf(fic,"executable    = %s\n",(*it).GetApplicationPath().toChar());
    fprintf(fic,"arguments     = %s\n",(*it).GetCurrentCommandLineArguments(true).c_str());  
    
#ifdef WIN32 
    fprintf(fic,"requirements  = (OpSys == \"WINNT50\") || (OpSys == \"WINNT51\") \n");
#endif

    // Check if we have external data
    const std::vector<ApplicationWrapperParam> & params = (*it).GetParams();
    std::vector<ApplicationWrapperParam>::const_iterator itParams = params.begin();

    std::string externalData = "";
    while(itParams != params.end())
      {
      if((*itParams).GetExternalData())
        {
        if(externalData.size()>0)
          {
          externalData += ",";
          }
        externalData += (*itParams).GetValue().toChar();
        }
      itParams++;
      }

    if(externalData.size() > 0)
      {
      fprintf(fic,"should_transfer_files = yes\n");
      fprintf(fic,"transfer_input_files = %s\n",externalData.c_str());
      fprintf(fic,"when_to_transfer_output = ON_EXIT_OR_EVICT\n");
      }

    fprintf(fic,"queue 1\n");
    it++;
    }
  fclose(fic);
}

} // end namespace bm
